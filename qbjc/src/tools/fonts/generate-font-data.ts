/** @file Generate glyph matrix data from on font files. */
import {createCanvas, registerFont} from 'canvas';
import {chunk} from 'lodash';
import path from 'path';
import {FontInfo} from '../../runtime/display/font';
import fs from 'fs-extra';

/** Information about each font to process. */
interface FontSpec extends FontInfo {
  /** Font family. Must match font family name in the font file. */
  fontFamily: string;
  /** Font file name on disk. */
  fontFileName: string;
}

/** Bundled fonts. */
const FONT_SPECS: Array<FontSpec> = [
  {
    name: '8x8',
    fontFamily: 'Mx437 IBM CGA',
    fontFileName: 'Mx437_IBM_CGA.ttf',
    width: 8,
    height: 8,
  },
];
/** Path to bundled fonts. */
const FONT_DIR_PATH = path.join(
  __dirname,
  '..',
  '..',
  '..',
  'src',
  'tools',
  'fonts'
);
/** Path to output font data. */
const FONT_DATA_FILE_PATH = path.join(
  __dirname,
  '..',
  '..',
  '..',
  'src',
  'runtime',
  'display',
  'font-data.ts'
);

/** Generates glyph matrix data for a font. */
function buildGlyphMatrix({
  name,
  fontFamily,
  fontFileName,
  width,
  height,
}: FontSpec) {
  const fontFilePath = path.join(FONT_DIR_PATH, fontFileName);
  registerFont(fontFilePath, {
    // For some strange reason, this needs to be a string that's different from
    // the actual font family name in the font file. This is probably a bug in
    // the `canvas` library but whatever works I guess ¯\_(ツ)_/¯
    family: name,
  });
  const canvas = createCanvas(width, height);
  const ctx = canvas.getContext('2d');
  ctx.font = `${height}px "${fontFamily}"`;
  ctx.antialias = 'none';
  ctx.textBaseline = 'top';
  const glyphs: Array<Array<Array<number>>> = Array.from(
    {length: 256},
    (_, ch) => {
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = '#ffffff';
      ctx.fillText(String.fromCharCode(ch), 0, 0);
      // Uncomment the following to output the canvas to a PNG file for debugging.
      /*
      const pngBuffer = canvas.toBuffer('image/png');
      fs.writeFile(
        path.join(
          fontDirPath,
          'glyphs',
          `${ch.toString(16).padStart(2, '0')}.png`
        ),
        pngBuffer
      );
      */
      const imageData = ctx.getImageData(0, 0, width, height);
      const matrix = chunk(
        chunk(imageData.data, 4).map((p) => (p[0] > 0 ? 1 : 0)),
        width
      );
      return matrix;
    }
  );
  return glyphs;
}

function glyphMatrixToJs(
  glyphMatrix: Array<Array<Array<number>>>,
  indent: number
) {
  const lines: Array<string> = [];
  lines.push('[');
  glyphMatrix.forEach((matrix, ch) => {
    const hexStr = `0x${ch.toString(16).padStart(2, '0')}`;
    const decStr = ch.toString();
    lines.push(`  [  // ${hexStr} / ${decStr}`);
    for (const row of matrix) {
      lines.push(`    ${JSON.stringify(row)},`);
    }
    lines.push(`  ],`);
  });
  lines.push(']');
  return lines.join(`\n${' '.repeat(indent)}`);
}

export async function generateFontDataFile() {
  const lines: Array<string> = [];
  lines.push(
    '// Generated by generate-font-data.ts',
    '',
    `import {Font} from './font';`,
    '',
    'export const FONT_DATA: Array<Font> = ['
  );
  for (const fontSpec of FONT_SPECS) {
    console.log(`> Processing ${fontSpec.fontFileName} => ${fontSpec.name}`);
    const glyphMatrix = buildGlyphMatrix(fontSpec);
    const glyphMatrixJs = glyphMatrixToJs(glyphMatrix, 4);
    lines.push(
      `  // Generated from ${fontSpec.fontFileName}`,
      `  {  `,
      `    name: '${fontSpec.name}',`,
      `    width: ${fontSpec.width},`,
      `    height: ${fontSpec.height},`,
      `    glyphs: ${glyphMatrixJs},`,
      `  },`
    );
  }
  lines.push('];');
  const content = lines.join('\n');

  console.log(`> Writing ${FONT_DATA_FILE_PATH}`);
  await fs.writeFile(FONT_DATA_FILE_PATH, content);
}

if (require.main === module) {
  generateFontDataFile();
}
